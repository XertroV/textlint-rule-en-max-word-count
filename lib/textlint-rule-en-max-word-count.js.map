{"version":3,"sources":["../src/textlint-rule-en-max-word-count.js"],"names":["defaultOptions","max","report","context","options","Syntax","getSource","RuleError","maxWordCount","Paragraph","node","filteredNode","type","Code","value","source","StringSource","text","toString","sentences","filter","SplitterSyntax","Sentence","forEach","sentence","sentenceText","words","length","originalIndex","originalIndexFromPosition","loc","start","sentenceFragment","slice","join","ruleError","index","module","exports"],"mappings":";;AAGA;;AAGA;;AAGA;;AAGA;;AACA;;;;;;AAEA;AACA,IAAMA,cAAc,GAAG;AACnB;AACAC,EAAAA,GAAG,EAAE;AAFc,CAAvB;AAIA;AACA;AACA;AACA;;AACA,SAASC,MAAT,CAAgBC,OAAhB,EAAuC;AAAA,MAAdC,OAAc,uEAAJ,EAAI;AAAA,MAC5BC,MAD4B,GACYF,OADZ,CAC5BE,MAD4B;AAAA,MACpBC,SADoB,GACYH,OADZ,CACpBG,SADoB;AAAA,MACTC,SADS,GACYJ,OADZ,CACTI,SADS;AAAA,MACEL,MADF,GACYC,OADZ,CACED,MADF;AAEnC,MAAMM,YAAY,GAAGJ,OAAO,CAACH,GAAR,GAAcG,OAAO,CAACH,GAAtB,GAA4BD,cAAc,CAACC,GAAhE;AACA,6BACKI,MAAM,CAACI,SADZ,YACuBC,IADvB,EAC4B;AACpB;AACA;AACA,QAAMC,YAAY,GAAG,8BAAID,IAAJ,EAAU,UAACA,IAAD,EAAU;AACrC,UAAIA,IAAI,CAACE,IAAL,KAAcP,MAAM,CAACQ,IAAzB,EAA+B;AAC3B;AACA,eAAO,8BAAa,EAAb,EAAiBH,IAAjB,EAAuB;AAC1BI,UAAAA,KAAK,EAAE;AADmB,SAAvB,CAAP;AAGH;;AACD,aAAOJ,IAAP;AACH,KARoB,CAArB;AASA,QAAMK,MAAM,GAAG,IAAIC,gCAAJ,CAAiBL,YAAjB,CAAf,CAZoB,CAapB;;AACA,QAAMM,IAAI,GAAGF,MAAM,CAACG,QAAP,EAAb,CAdoB,CAepB;;AACA,QAAMC,SAAS,GAAG,6BAAcF,IAAd,EAAoBG,MAApB,CAA2B,UAAAV,IAAI,EAAI;AACjD;AACA,aAAOA,IAAI,CAACE,IAAL,KAAcS,yBAAeC,QAApC;AACH,KAHiB,CAAlB,CAhBoB,CAoBpB;;AACAH,IAAAA,SAAS,CAACI,OAAV,CAAkB,UAAAC,QAAQ,EAAI;AAC1B;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACgB,UAAMC,YAAY,GAAGD,QAAQ,CAACV,KAA9B,CAV0B,CAW1B;;AACA,UAAMY,KAAK,GAAG,4BAAWD,YAAX,CAAd,CAZ0B,CAa1B;;AACA,UAAIC,KAAK,CAACC,MAAN,GAAenB,YAAnB,EAAiC;AAC7B;AACA,YAAMoB,aAAa,GAAGb,MAAM,CAACc,yBAAP,CAAiCL,QAAQ,CAACM,GAAT,CAAaC,KAA9C,CAAtB;AACA,YAAMC,gBAAgB,aAAMN,KAAK,CAACO,KAAN,CAAY,CAAZ,EAAc,CAAd,EAAiBC,IAAjB,CAAsB,GAAtB,CAAN,SAAtB;AACA,YAAMC,SAAS,GAAG,IAAI5B,SAAJ,+BAAqCC,YAArC,yBAAgEkB,KAAK,CAACC,MAAtE,oBAAqFK,gBAArF,UAA2G;AACzHI,UAAAA,KAAK,EAAER;AADkH,SAA3G,CAAlB;AAGA1B,QAAAA,MAAM,CAACQ,IAAD,EAAOyB,SAAP,CAAN;AACH;AACJ,KAvBD;AAwBH,GA9CL;AAgDH;;AACDE,MAAM,CAACC,OAAP,GAAiBpC,MAAjB","sourcesContent":["// Helper for creating new AST using map function\n// https://github.com/azu/unist-util-map\n// if you want to filter, use https://github.com/eush77/unist-util-filter\nimport map from \"unist-util-map\";\n// Helper for converting plain text from Syntax-ed text(markdown AST\n// https://github.com/azu/textlint-util-to-string\nimport StringSource from \"textlint-util-to-string\";\n// Helper for splitting text to sentences\n// https://github.com/azu/sentence-splitter\nimport {split as splitSentence, Syntax as SplitterSyntax} from \"sentence-splitter\";\n// Helper for splitting text to words\n// https://github.com/timjrobinson/split-string-words\nimport {splitWords} from \"./split-words\";\nimport ObjectAssign from \"object-assign\";\n\n// Default options\nconst defaultOptions = {\n    // max count of words >\n    max: 50\n};\n/**\n * @param {TextLintRuleContext} context\n * @param {Object} options\n */\nfunction report(context, options = {}) {\n    const {Syntax, getSource, RuleError, report} = context;\n    const maxWordCount = options.max ? options.max : defaultOptions.max;\n    return {\n        [Syntax.Paragraph](node){\n            // replace code with dummy code\n            // if you want to filter(remove) code, use https://github.com/eush77/unist-util-filter\n            const filteredNode = map(node, (node) => {\n                if (node.type === Syntax.Code) {\n                    // only change `value` to dummy\n                    return ObjectAssign({}, node, {\n                        value: \"code\"\n                    });\n                }\n                return node;\n            });\n            const source = new StringSource(filteredNode);\n            // text in a paragraph\n            const text = source.toString();\n            // get sentences from Paragraph\n            const sentences = splitSentence(text).filter(node => {\n                // ignore break line\n                return node.type === SplitterSyntax.Sentence;\n            });\n            // text in a sentence\n            sentences.forEach(sentence => {\n                /* sentence object is a node\n                {\n                    type: \"Sentence\",\n                    raw: text,\n                    value: text,\n                    loc: loc,\n                    range: range\n                };\n                 */\n                const sentenceText = sentence.value;\n                // words in a sentence\n                const words = splitWords(sentenceText);\n                // over count of word, then report error\n                if (words.length > maxWordCount) {\n                    // get original index value of sentence.loc.start\n                    const originalIndex = source.originalIndexFromPosition(sentence.loc.start);\n                    const sentenceFragment = `${words.slice(0,3).join(' ')} ...`;\n                    const ruleError = new RuleError(`Maximum word count (${maxWordCount}) exceeded (${words.length}) by \"${sentenceFragment}\".`, {\n                        index: originalIndex\n                    });\n                    report(node, ruleError);\n                }\n            });\n        }\n    };\n}\nmodule.exports = report;\n"],"file":"textlint-rule-en-max-word-count.js"}